from __future__ import annotations

from datetime import datetime, timezone
from pathlib import Path
import argparse


DEFAULT_TARGET = Path("merkaz_backend") / "version.py"
HEADER_NOTE = "This file is auto-generated by semantic-release.\nDo not edit manually."


def render_content(version: str, release_date: str, target_path: Path) -> str:
    suffix = target_path.suffix.lower()

    if suffix == ".py":
        return (
            "\"\"\"\n"
            f"{HEADER_NOTE}\n"
            "\"\"\"\n\n"
            "__all__ = ['__version__', '__release_date__']\n\n"
            f"__version__ = '{version}'\n"
            f"__release_date__ = '{release_date}'\n"
        )

    if suffix == ".ts":
        return (
            "// ------------------------------------------------------------\n"
            "// THIS FILE IS AUTO-GENERATED BY SEMANTIC-RELEASE.\n"
            "// DO NOT EDIT MANUALLY.\n"
            "// ------------------------------------------------------------\n\n"
            "export interface VersionInfo {\n"
            "  version: string;\n"
            "  releaseDate: string;\n"
            "}\n\n"
            "export const versionInfo: VersionInfo = {\n"
            f"  version: '{version}',\n"
            f"  releaseDate: '{release_date}',\n"
            "};\n"
        )

    if suffix == ".json":
        return (
            "{\n"
            f'  "version": "{version}",\n'
            f'  "releaseDate": "{release_date}"\n'
            "}\n"
        )

    raise ValueError(
        f"Unsupported target format '{suffix}'. "
        "Supported formats: .py, .ts, .json"
    )


def write_version_file(version: str, target_path: Path) -> None:
    """Write the current semantic-release version to the specified file."""
    timestamp = datetime.now(tz=timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    content = render_content(version=version, release_date=timestamp, target_path=target_path)

    target_path.parent.mkdir(parents=True, exist_ok=True)
    target_path.write_text(content, encoding="utf-8")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Write the current semantic-release version to a Python module."
    )
    parser.add_argument("version", help="Version string produced by semantic-release.")
    parser.add_argument(
        "--target",
        default=str(DEFAULT_TARGET),
        help=(
            "Relative path (from repository root) of the file to write. "
            f"Default: {DEFAULT_TARGET.as_posix()}"
        ),
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()

    project_root = Path(__file__).resolve().parents[1]
    target_path = (project_root / args.target).resolve()

    write_version_file(args.version, target_path=target_path)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
